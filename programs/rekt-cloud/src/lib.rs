use borsh::{BorshSerialize, BorshDeserialize};
use solana_program::{declare_id, msg, entrypoint::ProgramResult, account_info::{AccountInfo, next_account_info}, pubkey::Pubkey, borsh::try_from_slice_unchecked, program_error::ProgramError, system_program};
use solana_program::entrypoint;

declare_id!("RektC1oud1111111111111111111111111111111112");

#[derive(BorshSerialize, BorshDeserialize)]
pub enum Action {
    Initialize,
    Write { offset: u64, data: Vec<u8> },
    Resize { size: u64 },
    Close,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Update {
    pub actions: Vec<Action>,
}

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    msg!("Welcome to Rekt cloud");

    msg!("{:?}", accounts);
    let accounts_iter = &mut accounts.iter();

    let authority = next_account_info(accounts_iter)?;

    if !authority.is_signer {
        return Err(ProgramError::IncorrectProgramId);
    }

    let update: Update = try_from_slice_unchecked(instruction_data)?;

    for action in update.actions {
        let storage = next_account_info(accounts_iter)?;
        if storage.owner != program_id {
            msg!("Storage account does not have the correct program id");
            return Err(ProgramError::IncorrectProgramId);
        }

        match action {
            Action::Initialize => {
                msg!("Initializing {}...", storage.key);

                let storage_authority = Pubkey::new(&storage.data.borrow()[0..32]);
                if storage_authority != Pubkey::default() {
                    msg!("Storage account authority is already set");
                    return Err(ProgramError::InvalidAccountData);
                }
                // Write authority pubkey
                let mut storage_data = storage.data.borrow_mut();
                storage_data[0..32].copy_from_slice(&authority.key.to_bytes());
            }
            Action::Write { offset, data } => {
                msg!("Writing to {}...", storage.key);
                let storage_authority = Pubkey::new(&storage.data.borrow()[0..32]);
                if &storage_authority != authority.key {
                    msg!("Storage account authority is {} not {}", storage_authority, authority.key);
                    return Err(ProgramError::InvalidAccountData);
                }
                // Check that offset >= 32 and that the write is within the storage account data size
                if offset < 32 {
                    msg!("Offset would overwrite authority");
                    return Err(ProgramError::InvalidInstructionData);
                }
                if offset as usize + data.len() > storage.data_len() {
                    msg!("Writing after end of data len");
                    return Err(ProgramError::InvalidInstructionData);
                }
                msg!("Writing at {}, original data: {:?}", offset, &storage.data.borrow()[offset as usize..offset as usize + data.len()]);
                storage.data.borrow_mut()[offset as usize..offset as usize + data.len()].copy_from_slice(&data);
            }
            Action::Resize { size } => {
                msg!("Resizing {}...", storage.key);
                let storage_authority = Pubkey::new(&storage.data.borrow()[0..32]);
                if &storage_authority != authority.key {
                    msg!("Storage account authority is {} not {}", storage_authority, authority.key);
                    return Err(ProgramError::InvalidAccountData);
                }

                storage.realloc(size as usize, false)?;
            }
            Action::Close => {
                msg!("Closing {}...", storage.key);
                let storage_authority = Pubkey::new(&storage.data.borrow()[0..32]);
                if &storage_authority != authority.key {
                    msg!("Storage account authority is {} not {}", storage_authority, authority.key);
                    return Err(ProgramError::InvalidAccountData);
                }

                **authority.lamports.borrow_mut() = authority.lamports()
                    .checked_add(storage.lamports())
                    .ok_or(ProgramError::Custom(0))?;
                **storage.lamports.borrow_mut() = 0;
                storage.assign(&system_program::ID);
                storage.realloc(0, false)?;
            }
        }
    }

    msg!("See you later!");

    Ok(())
}
